package ravensproject;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


/**
 * This class solves for the RPM that have only one object
 * in a figure. This class only deals with 2 by 2 RPMs.
 */


public class ThreeByThree2Obj {

	private RavensProblem problem;
	private int tempAns;

	//hash map for Ravens Figure
	private HashMap<String, RavensFigure> RF;
	//Ravens figure
	private RavensFigure RFE, RFF, RFH, RF1, RF2, RF3, RF4, RF5, RF6, RF7, RF8;
	
	private List<Map> ravensFigure = new ArrayList();
	
	//Hash map of Ravens object
	private HashMap<String, RavensObject> ROE, ROF, ROH, RO1, RO2, RO3, RO4, RO5, RO6, RO7, RO8;
	//Ravens object in each figure
	private RavensObject ROf, ROg, ROh, ROi, ROm, ROn, ROo;
	//attributes for Ravens object
	private HashMap<String, String> ROfa, ROga, ROha, ROia, ROma, ROna, ROoa;
	//map of the Ravens object and its attributes in a list
	@SuppressWarnings({ "rawtypes", "unchecked" })
	private List<Map> resultAttribute = new ArrayList(); //array list for the result object attributes

	private String shapeC, fillC, shapeB, fillB; //for the object c
	private String shapeAns, fillAns, shapeAlignmentAns; //potential result

	private String angleA, angleB, angleC, angleAns, shapeAlignmentA, shapeAlignmentC, shapeAlignmentB; //angle of C for rotation cases
	private int angleP_int, angleQ_int, diffAB, diffAC; //angle of C for rotation cases

	public ThreeByThree2Obj (RavensProblem problem) {
		this.problem = problem;
	}


	public int oneObjectRPM() {
		resultAttribute = getObjectAttributes(problem);
		shapeChecker();

		try {
			if (ROaa.equals(ROba)) {
				tempAns = figureAEqualsB();
			} else if (ROaa.equals(ROca)) {
				tempAns = figureAEqualsC();
			} else if (ROaa.containsKey("alignment") && ROaa.get("fill").equals(ROca.get("fill"))) {
				tempAns = differentFigReflection();
			} else if (ROaa.containsKey("alignment") && !ROaa.get("fill").equals(ROca.get("fill"))) {
				tempAns = differentFigReflectionDiffFill();
			} else if ((ROaa.get("shape")).equals(ROba.get("shape")) && !ROaa.containsKey("angle")) { // for same shape from A to B but different fill
				//System.out.println("Shape of ROaa " + ROaa.get("shape") + " and shape of ROba " + ROba.get("shape"));
				tempAns = figureAEqualsBDiffFill();
			} else if ((ROaa.get("shape")).equals(ROca.get("shape")) && !ROaa.containsKey("angle")) { // for same shape from A to C but different fill
				tempAns = figureAEqualsCDiffFill();
			} else if (ROaa.containsKey("angle")){ //case of reflection
				if (!(ROaa.get("fill").equals(ROca.get("fill"))) || !(ROaa.get("fill").equals(ROba.get("fill")))) { //case of reflection of same figures with different fill
					tempAns = figureReflectionDiffFill();
				} else { //case of reflection of same figures with same fill
					tempAns = figureReflection();
				}
			} 
			else {
				tempAns = -1;
			}	
		} catch(NullPointerException e){
			System.out.println("Exception thrown  :" + e);
		}
		return tempAns;
	}
	
	@SuppressWarnings("rawtypes")
	private int test1(RavensProblem problem) { //returns the object attributes in a list
		
		for (String figureName : problem.getFigures().keySet()) {
			RavensFigure thisFigure = problem.getFigures().get(figureName);
			ravensFigure.add((Map) thisFigure);
		}
		
		System.out.println("This is ravensFigure Arraylist: " + ravensFigure);
		return -1;
	}
}
